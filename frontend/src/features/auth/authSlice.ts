import {createSlice, createAsyncThunk} from '@reduxjs/toolkit'; 
import authService from './authService'; 

export interface AuthState { 
	user: string | null,
	isError: boolean; 
	isSuccess: boolean; 
	isLoading: false;
	message: unknown | string;
}

// Get user from localStorage 
//@ts-ignore
const user = JSON.parse(localStorage.getItem('user'));

const initialState : AuthState = {
	user: user ? user : null, 
	isError: false,
	isSuccess :false, 
	isLoading: false,
	message: '', 
}

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
// export const incrementAsync = createAsyncThunk(
// 	'counter/fetchCount',
// 	async (amount: number) => {
// 	  const response = await fetchCount(amount);
// 	  // The value we return becomes the `fulfilled` action payload
// 	  return response.data;
// 	}
//   );

// Register new user 
export const register = createAsyncThunk('auth/register', async(user, thunkAPI) => {
	try {
		return await authService.register(user)
	} catch (error:any) {
		const message = (error.response && error.response.data && error.response.data.message) 
		|| error.message || error.toString();
		return thunkAPI.rejectWithValue(message)
	}
})

// Login new user 
export const login = createAsyncThunk('auth/login', async(user, thunkAPI) => {
	try {
		return await authService.login(user)
	} catch (error:any) {
		const message = (error.response && error.response.data && error.response.data.message) 
		|| error.message || error.toString();
		return thunkAPI.rejectWithValue(message)
	}
})

//logout user 
export const logout = createAsyncThunk('auth/logout', async() => {
	await authService.logout()
})


export const authSlice = createSlice({
	name: 'auth',
	initialState, 
	// The `reducers` field lets us define reducers and generate associated actions
	reducers: {
		reset: (state) => {
			state.isLoading = false
			state.isError = false
			state.isSuccess = false 
			state.message = ''
		},
	},
	// The `extraReducers` field lets the slice handle actions defined elsewhere,
   // including actions generated by createAsyncThunk or in other slices.
	extraReducers : (builder) => {
		builder
		.addCase(register.pending, (state, action) => {
		//@ts-ignore
		  state.isLoading = true
		})
		.addCase(register.fulfilled, (state, action) => {
			state.isLoading = false
			state.isSuccess = true
			//@ts-ignore
			state.user = action.payload
		})
		.addCase(register.rejected, (state, action) => {
			state.isLoading = false
			state.isError = true
			state.message = action.payload
			state.user = null
		})
		.addCase(login.pending, (state, action) => {
			// @ts-ignore
			state.isLoading = true
		  })
		  .addCase(login.fulfilled, (state, action) => {
			  state.isLoading = false
			  state.isSuccess = true
			  //@ts-ignore
			  state.user = action.payload
		  })
		  .addCase(login.rejected, (state, action) => {
			  state.isLoading = false
			  state.isError = true
			  state.message = action.payload
			  state.user = null
		  })
		  .addCase(logout.fulfilled, (state) => {
			state.user = null
		})
	}
})

export const {reset} = authSlice.actions; 
export default authSlice.reducer; 

